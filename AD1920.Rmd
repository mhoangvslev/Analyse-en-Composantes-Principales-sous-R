---
title: "Analyse en Composantes Principales sous R"
author: "Minh-Hoang DANG"
output:
  pdf_document: default
  html_notebook: default
---

# Introduction

# Les données
Nous avons un jeu de données contenant 1000 gènes de 40 individus. Les 20 premiers individus sont en bonne santé et les autres sont malades. A travers des analyses, nous visons à détecter les gènes qui contribue à la maladie.

```{r}
genes <- read.csv("/media/minhhoangdang/WINDOWS/Users/minhh/OneDrive/UnivN/M1/DataAnalysis/Projet/Docs/Projet M1 AD 1920.csv", header=FALSE)
```

## Résumé des données
```{r}
summary(genes)
```

```{r}
boxplot(t(genes))
```

```{r}
y<-c(2,1,3,4,5,0,7,6,9,2)
Y<-matrix(y,ncol=2,byrow = T) #; Y
x<-c(1,0,0,1,1,0,1,2,0,0,2,1,0,1,1,0,0,1)
X<-matrix(x,ncol=3,byrow = T)

ACP<-function(data,reduite=FALSE,nbAxes=2){
    # Procedures 1 et 2
    print("Matrice centree reduite :")
    dCentree<-scale(data,scale=reduite) ; print(dCentree)
    
    # Procedure 3
    nbIndiv<-nrow(dCentree)
    print("Matrice d'inertie")
    SI<-(1/nbIndiv)*t(dCentree)%*%dCentree ; print(SI)
    
    # Procedure 4
    eig <- eigen(SI) ; print(eig)
    valp <- round(eig$values,3) ; vecp <- round(eig$vectors,3)
    rang <- length(valp[valp >0]) ; cval <- valp[1:rang]
    print(rang) ; print(cval)
    # print("Axes principaux / vecteurs propres")
    # print(round(eig$values,2)) ; print(round(vecp,2))

    # Procedure 5
    # print("Composantes principales")
    F=round(dCentree%*%vecp,2)
    plot(F)
    
    # Choix du nombre d'axes
    # Calcul des coordonnees des variables
    G<-matrix(0,nrow(SI),ncol(SI))
    for(indice in 1:nbAxes){
       G[,indice]=round(sqrt(valp[indice])%*%vecp[,indice],2)
    }
    
    contributions<-matrix(0,nbIndiv,nbAxes)
    for(indiv in 1:nbIndiv){
      for(axe in 1:nbAxes){
        contributions[indiv,axe]<-(((1/nbIndiv)*F[indiv,axe])/cval[axe])
      }
    }
    contributions<-round(contributions*100,2)
    print(contributions)
    # dim(data)
    # print(G)
    
    
    # Inertie cumulee
    # print(round(valp/sum(valp)*100,2))
    # print(valp) #; print(vecp)
    # print("# Inertie")
    # print(round(cumsum(valp/sum(valp)*100),2))
    
    # Calcul des contributions

}
ACP(t(genes));
```


---
title: "Analyse en Composantes Principales sous R"
author: "Minh-Hoang DANG"
output:
  pdf_document: default
  html_notebook: default
---

# Introduction

# Les données
Nous avons un jeu de données contenant les mesures sur 1000 gènes de 40 individus. Les 20 premiers individus sont en bonne santé et les autres sont malades. A travers des analyses, nous visons à détecter les gènes qui contribue à la maladie.

```{r}
genes <- read.csv("/media/minhhoangdang/WINDOWS/Users/minhh/OneDrive/UnivN/M1/DataAnalysis/Projet/Docs/Projet M1 AD 1920.csv", header=FALSE);

sains <- genes[, 1:20];
malades <- genes[, 21:40];

```

```{r}
boxplot(genes)
```
Les valeurs aberrantes sont plutôt présentes parmi les individus malades. Autrement dit, l’évaluation de ces valeurs peuvent potentiellement révéler les indicateurs concernant la maladie. 
```{r}
boxplot(t(genes))
```
Le diagramme en boîtes pour les 1000 gènes met en évidence 2 groupes de gènes qui diffèrent nettement des autres. Le premier groupe de gènes, entre 10 et 21. Le deuxième groupe de gènes, entre 501 et 601.

```{r}
groupe1 <- t(genes)[, 11:20];
groupe2 <- t(genes)[, 500:600];
```

On peut déduire la variabilité de l’expression des gènes est très faible entre les individus. Cependant, certains gènes s’exprime plus fortement que les autres et parmi les gènes dont l’expression est supérieure, la variabilité est plutôt faible.

# ACP sous R
## Calculer le centre de gravité
```{r}
test.gravity <- colMeans(genes);
test.nbIndv <- nrow(genes);
test.nbVars <- ncol(genes);
```

## Calculer la matrice centrée
```{r}
reduite = TRUE;
test.scaled <- apply(genes, 2, function(col) (col - mean(col))/ if (reduite) (sd(col) * sqrt((test.nbIndv-1)/test.nbIndv)) else 1);

test.scaled2 <- scale(genes, center = TRUE, scale = TRUE)
```

## Calculer la matrice d'inertie
$$S = \frac{1}{n}Y_c^\top \times Y_c$$

```{r}
test.inertie <- (1/test.nbIndv) * t(test.scaled) %*% test.scaled;
test.Ig <- sum(diag(test.inertie));
```

## Des valeurs propres et les vecteurs propres
```{r}
eig <- eigen(test.inertie);
test.eigenwerts <- eig$values;
test.eigenvektors <- eig$vectors;

test.percentageInertie <- test.eigenwerts * 100/test.Ig;


pie(test.percentageInertie, 
    labels = round(test.percentageInertie, 1), 
    col = rainbow(length(test.percentageInertie)),
    main = "Pourcentage d'inertie associé à chaque axe")
legend( x = "topright", legend = round(test.eigenwerts, 2), cex = 0.8, fill = rainbow(length(test.percentageInertie)))
```

## Composantes principales
$F = Y_c \times U$ est la projection de $Y$. Chaque observation est une combinaison de la variable originelle et leur poids est determiné par les valeurs propres (les axes principaux).

```{r}
nbComponents <- 2 
test.components <- test.scaled %*% test.eigenvektors[, 1:nbComponents]
```


## Coordonnées des variables
```{r}
test.coords <- matrix(0, test.nbIndv, nbComponents)
    for(indice in 1:nbComponents){
       test.coords2[,indice] <- round(sqrt(test.eigenwerts[indice]) * test.eigenvektors[, indice], 2)
    };

test.coords2 <- matrix(
  unlist(
    lapply(1:nbComponents, function(indice){
       round(sqrt(test.eigenwerts[indice]) * test.eigenvektors[, indice], 2)
    })), ncol = nbComponents, nrow = test.nbIndv);

all(test.coords2 == test.coords3) #Expected TRUE
```

## Contribution absolue
```{r}
test.absContrib <- matrix(0, nrow = test.nbIndv, ncol = nbComponents)
for(indiv in 1:test.nbIndv){
    for(axe in 1:nbComponents){
        test.absContrib[indiv,axe]<-(((1/test.nbIndv)*test.components[indiv,axe]**2)/test.eigenwerts[axe])
    }
}
test.absContrib<-round(test.absContrib*100,2)


test.absContrib2 <- matrix(unlist(
  lapply(1:nbComponents, function(axe){
    round(
      (100/(test.nbIndv*test.eigenwerts[axe])) * sapply(test.components[,axe], function(x){x**2}), 2)
  })), nrow = test.nbIndv, ncol = nbComponents);


all(test.absContrib == test.absContrib2)
```

contributions<-matrix(0,nbIndiv,nbAxes)
    

## Finalement, la fonction ACP de notre rêve!
```{r}
ACP <- function(data, standardisation = FALSE, nbComps = 2 ) {
  
  result <- NULL;
  
  # Calcul des valeurs intermédiaires
  result$gravity <- colMeans(genes);
  result$nbIndv <- nrow(genes);
  result$nbVars <- ncol(genes);
  
  # Centrer et/ou réduire les données
  result$scaled <- apply(genes, 2, function(col){
     (col - mean(col))/ if (standardisation) (sd(col) * sqrt((result$nbIndv-1)/result$nbIndv)) else 1;
  });
  #result$scaled <- scale(genes, center = TRUE, scale = TRUE);
  
  # Calculer la matrice d'inertie
  result$inertie <- (1/result$nbIndv) * t(result$scaled) %*% result$scaled;
  result$Ig <- sum(diag(result$inertie));
  
  if(standardisation) {
      library(corrplot);
      corrplot(result$inertie, type="upper", order="hclust", tl.col="black")
  }
  
  # Des valeurs propres et les vecteurs propres
  eig <- eigen(result$inertie);
  result$eigenwerts <- eig$values;
  result$eigenvektors <- eig$vectors;
  
  result$percentageInertie <- result$eigenwerts * 100/result$Ig;
  
  pie(result$percentageInertie, 
    labels = round(result$percentageInertie, 1), 
    col = rainbow(length(result$percentageInertie)),
    main = "Pourcentage d'inertie associé à chaque axe")
  legend("topright", legend = round(result$eigenwerts, 2), cex = 0.8, fill = rainbow(length(result$percentageInertie)))
  
  # Composantes principales
  result$components <- result$scaled %*% result$eigenvektors[, 1:nbComps];
  
  ## Coordonnées des variables
  result$coords <- matrix(
    unlist(
      lapply(1:nbComponents, function(indice){
        round(sqrt(result$eigenwerts[indice]) * result$eigenvektors[, indice], 2)
      })), ncol = nbComponents, nrow = result$nbIndv);

  ## Contribution absolue
  result$absContrib <- matrix(unlist(
    lapply(1:nbComponents, function(axe){
      round(
        (100/(result$nbIndv*result$eigenwerts[axe])) * sapply(result$components[,axe], function(x){x**2}), 2)
    })), nrow = result$nbIndv, ncol = nbComponents);

  # Retourner le résultat
  return(result);
}
```

```{r}
testACP <- ACP(genes, standardisation = FALSE)
```


# Autres outil pour réaliser l'ACP
## ```FactorMineR```
```{r}
library(FactoMineR);
FMPCA <- PCA(t(genes), scale.unit = TRUE, ncp = 3);
FMPCA;
```

```{r}
FMPCA$eig
```

## ```prcomp```
```{r}
library(devtools)
install_github("vqv/ggbiplot")
```

```{r}
library(ggbiplot)
prc <- prcomp(genes, center = TRUE, scale. = TRUE)
ggbiplot(prc, ellipse = TRUE, circle = TRUE)
```

```{r}
#prc
```

